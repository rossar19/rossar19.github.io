---
layout: noheader
---

<h1 class="data-header">Happiness: A Global Affair</h1>
<p class="data-copy">"Imagine a ladder with steps numbered from 0 at the bottom to 10 at the top.  
The top represents the best possible life for you; the bottom, the worst possible life.  
On which step do you feel you personally stand at present time?"
<br /><br />
Participants from 43 countries were asked this question, and here's on average how they answered.
</p>

<div class="color-scale">
	<div class="sad">Low</div>
	<div class="ok">Mid</div>
	<div class="happy">High</div>
</div>

<div class="btn-wrapper"></div>

<div class="main-wrapper--countries"></div>
<div class="main-wrapper--data"></div>

<script>
	var pageTitle = "Happiness: A Global Affair";
	var cIndex;              // Index of country currently viewed
	var avgQ2ByCountry = []; // Array of each country's average happy rating

	// Data nested by categories
	var childrenNest;
	var countryNest;
	var happyNest;
	var genderNest;
	var ageNest;
	var employmentNest;
	var relationshipNest;
	var happyCountryNest;
	var countrySexHappy;
	var countryAgeHappy;
	var countryEmployHappy;
	var countryRelHappy;
	var countryChildHappy;

	var filters; // Categories to filter data

	// Keys in data
	var qHappiness = "Q2. Imagine a ladder with steps numbered from 0 at the bottom to 10 at the top.  The top represents the best possible life for you; the bottom, the worst possible life.  On which step do you feel you personally stand at present time?";
	var qGender = "Q132. Gender";
	var qAge = "Q133. How old were you at your last birthday?";
	var qEmployment = "Q140. Which of the following employment situations best describes your current status?";
	var qRelationship = "Q153. Are you currently married, in a legal civil union, widowed, divorced, separated, or none of these?";
	var qChildren = "Q157. How many children have you had?  Please count all your biological children who were born at any time in your life. [In Russia: but do not count adopted children or stepchildren].";

	var simulation; // Force simulation used for particles

	function drawPix(data) {
		var svg = d3.select(".main-wrapper--countries")
			.append("svg")
			.attr("width", 90)
			.attr("height", 200);

		var rects = svg.selectAll("rect").data(data.values);	  // Element for country
		var nameText = svg.selectAll("text").data(data);  // Element for country's name



	    function calculateX(index) {
	    	return 10 + (3*(index%25));
	    }

	    function calculateY(index, space) {
	    	space = (space == null) ? 0 : space;
	    	return (10 - space) + (3 * Math.floor(index/25));
	    }

	    var color = d3.scaleLinear()
	    .domain([0,5, 10])
	    .range(["#7B7B7B", "#7EC27E", "#ff0"]);

	    // "#7B7B7B", "#7EC27E", "#ff0"
	    // "#f00","#00f", "#ff0"

		rects.enter().append("rect")
		.attr("x", function(d, i) {
			return 10 + (3*(i%25));
		})
		.attr("y", function(d, i) {
			return 10 + (3 * Math.floor(i/25))
		})
		.attr("width", 2)
		.attr("height", 2)
		.attr("fill", function(d, i) {
			return color(d[qHappiness]);
		})
		.on("mouseover", function(d, i) {
			var offset = d3.select(".main-wrapper--countries").node().getBoundingClientRect();
			var x = parseInt(d3.select(this).attr("x")) + offset.left;
			var y = parseInt(d3.select(this).attr("y")) + offset.top;
			d3.select(".main-wrapper--countries")
				.append("span")
				.attr("class", "avg")
				.style("top", y + "px")
				.style("left", x + "px");
				//.text(avgQ2ByCountry[i].toFixed(1));
		})
		.on("mouseout", function(d, i) {
			d3.select(".main-wrapper--countries .avg")
				.remove();
		});

		// Add Text element to SVG
	    var name = nameText.enter().append("text")
	    .attr("x", function(d, i) {
	      return calculateX(i);
	    })
	    .attr("y", function(d, i) {
	    	return calculateY(i, 5);
	    })
	    .attr("id", function(d, i) {
	    	return "L" + i;
	    })
	    .attr("class", "country--name")
	    .html(function(d) {
	    	var html = d.key;
	    	if (d.key.length > 12) {
	    		var arr = d.key.split(" ");
	    		var x = d3.select(this).attr("x");
	    		html = '<tspan x="' + x + '" dy="-16">' + arr[0] + 
	    			'</tspan>' + '<tspan x="' + x + '" dy="16">' + 
	    			arr[1] + '</tspan>';
	    	}
	    	return html;
	    });

	    createOnClick(countryNest);
	}

	// Draw each country and color based on average happiness
	var drawAvg = function(data) {
		var svg = d3.select(".main-wrapper--countries")
			.append("svg")
			.attr("class", "country--svg");

		var rects = svg.selectAll("rect").data(data);     // Element for country
		var nameText = svg.selectAll("text").data(data);  // Element for country's name

		// Assign color based on average
	    var color = d3.scaleLinear()
	    .domain([4, 6, 8])
	    .range(["#7B7B7B", "#7EC27E", "#ff0"]);

	    function calculateX(index) {
	    	return 120*(index%10);
	    }

	    function calculateY(index, space) {
	    	space = (space == null) ? 0 : space;
	    	return (40 - space) + (125 * Math.floor(index/10));
	    }

	    // "#000", "#46535a", "#465f2c", 
	    // 		"#984350", "#91719a", "#f5c750", 
	    // 		"#a8c9d9", "#c1dea0", "#d796a5", 
	    // 		"#cdb5d7", "#f3d998"

	    // "#F00", "#00F", "#0F0"

	    // Add rectangle to SVG
		rects.enter().append("rect")
		.attr("id", function(d, i) {
			return "c" + i;
		})
		.attr("class", "country")
		.attr("x", function(d, i) {
			return calculateX(i);
		})
		.attr("y", function(d, i) {
			return calculateY(i);
		})
		.attr("width", 100)
		.attr("height", 50)
		.attr("fill", function(d, i) {
			return color(avgQ2ByCountry[i]);
		})
		.on("mouseover", function(d, i) {
			var offset = d3.select(".main-wrapper--countries").node().getBoundingClientRect();
			var x = parseInt(d3.select(this).attr("x")) + offset.left;
			var y = parseInt(d3.select(this).attr("y")) + offset.top;
			d3.select(".main-wrapper--countries")
				.append("span")
				.attr("class", "avg")
				.style("top", y + "px")
				.style("left", x + "px")
				.text(avgQ2ByCountry[i].toFixed(1));
		})
		.on("mouseout", function(d, i) {
			d3.select(".main-wrapper--countries .avg")
				.remove();
		});

		// Add Text element to SVG
	    var name = nameText.enter().append("text")
	    .attr("x", function(d, i) {
	      return calculateX(i);
	    })
	    .attr("y", function(d, i) {
	    	return calculateY(i, 5);
	    })
	    .attr("id", function(d, i) {
	    	return "L" + i;
	    })
	    .attr("class", "country--name")
	    .html(function(d) {
	    	var html = d.key;
	    	if (d.key.length > 12) {
	    		var arr = d.key.split(" ");
	    		var x = d3.select(this).attr("x");
	    		html = '<tspan x="' + x + '" dy="-16">' + arr[0] + 
	    			'</tspan>' + '<tspan x="' + x + '" dy="16">' + 
	    			arr[1] + '</tspan>';
	    	}
	    	return html;
	    });

	    createOnClick(data);
	}

	// Creates an on click function for each item in data
	function createOnClick(data) {
	    for (var n in data) {
	    	var id = "#c" + n;
	    	var mDataWrapper = d3.select(".main-wrapper--data");

			d3.select(id).on("click", function(e) {
				cIndex = this.id.replace("c", "");
				d3.select(".data-header").text(data[cIndex].key);

				d3.select(".main-wrapper--countries").style("display", "none");
				d3.select(".color-scale").style("display", "none");

				mDataWrapper.selectAll("*").remove();
				mDataWrapper.style("display", "block");
				d3.select(".btn-wrapper").style("display", "inline-block");
				addFilterBtns();
			});
	    }
	}

	// Adds filter buttons
	function addFilterBtns() {
	    var mDataWrapper = d3.select(".main-wrapper--data");

		var btnWrap = d3.select(".btn-wrapper");

		var dataWrap = mDataWrapper
			.append("div")
			.attr("class", "data-wrapper");

		d3.select(".data-copy")
			.append("a")
			.attr("class", "back-btn")
			.attr("href", "javascript:goBack()")
			.text("Choose a different country");

		// Return an array of keys from data's children
		function getChildArr(data) {
			var arr = [];

			if (isNaN(parseInt(data[0].key))) {
				for (var n in data) {
					if (data[n].key != "Refused" && data[n].key != "Dont know") {
						arr.push(data[n].key);
					}
				}
			} else {
				for (var n in data) {
					if (data[n].key < 98 && data[n].key != "") {
						arr.push(data[n].key);
					}
				}
			}
			return arr;
		}

		filters = {
			"Happy": ["Happiness"],
			"Sex": getChildArr(genderNest),
			"Age": getChildArr(ageNest).sort(function(a,b) {return a-b}),
			"Job Status": getChildArr(employmentNest),
			"Marital Status": getChildArr(relationshipNest),
			"# of Children": getChildArr(childrenNest).sort(function(a,b) {return a-b})
		};

		// Create a button for each item in filters and create onclick functions
		for (var n in filters) {
			var btn = btnWrap.append("button")
			.attr("id", n)
			.attr("class", "filter-btn")
			.text(n);

			// If first load, display subcategories of first item in filters
			if (d3.select(".data-wrapper").html() == "") {
				displaySubs(filters[n], n);
			}

			// On click, clear old children and add new subcategories
			btn.on("click", function(e) {
				dataWrap.selectAll("*").remove();
				displaySubs(filters[this.id], this.id);
			});
		}
	}

	// Add subcategories to page
	function displaySubs(arr, filter) {
		var objArr = [];

		for (var n in arr) {
			var cat = d3.select(".data-wrapper").append("span")
				.attr("class", "category")
				.attr("id", "cat" + n)
				.text(arr[n])
				.on("mouseover", function(e) {
					console.log("hover");
				});
		}

		cat.on("mouseover", function(e) {
			console.log("hover");
		});

		setSubcatCoords(objArr);
		drawClusters(countryNest, objArr, cIndex, filter);
	}

	// Calculate subcategory coordinates for data positioning, and push object to array 
	function setSubcatCoords(arr) {
		d3.selectAll(".category").each(function() {
			var w = this.getBoundingClientRect().width;
			var h = this.getBoundingClientRect().height;
			var l = this.getBoundingClientRect().left;
			var t = this.getBoundingClientRect().top;

			var xOffset = d3.select(".data-wrapper").node().getBoundingClientRect().left;
			var yOffset = d3.select(".data-wrapper").node().getBoundingClientRect().top;

			var temp = {
				"key": d3.select(this).text(),
				"x": l + (w/2) - xOffset,
				"y": t + (h/2) - yOffset
			}

			arr.push(temp);
		});
	}

	// Return to homepage
	function goBack() {
		d3.select('.back-btn').remove();
		d3.select('.data-header').text(pageTitle);
		d3.select('.main-wrapper--data').style("display", "none");
		d3.select('.main-wrapper--countries').style("display", "block");
		d3.select(".color-scale").style("display", "inline-block");
		d3.select(".btn-wrapper").style("display", "none");
		d3.select(".btn-wrapper").selectAll("*").remove();

		simulation.stop();
		d3.select(".data-wrapper svg").remove();
	}

	// Calculate the happy percent breakdown of a country
	// pass country > category > happy rating
	function calcPercent(country, lvl) {
		lvl = (lvl == null) ? false : true;
		var temp = [];


	    var color = d3.scaleLinear()
	    .domain([0,1,2,3,4,5,6,7,8,9,10])
	    .range(["#000", "#46535a", "#465f2c", 
	    		"#984350", "#91719a", "#f5c750", 
	    		"#a8c9d9", "#c1dea0", "#d796a5", 
	    		"#cdb5d7", "#f3d998"]);

		if (lvl) {
			var total = 0;

			for (var i in country.values) {
				total = total + country.values[i].values.length;

				if (parseInt(country.values[i].key) < 97) {
					obj = {
						"key": country.values[i].key,
						"percent": country.values[i].values.length,
						"color": color(country.values[i].key)
					}

					temp.push(obj);
				}
			}

			for (var i in temp) {
				temp[i].percent = ((temp[i].percent / total) * 100).toFixed(2);
			}
		} else {
			for (var i in country.values) {
				if ((isNaN(parseInt(country.values[i].key))
						&& country.values[i].key != "Refused" 
						&& country.values[i].key != "Dont know") ||
					(parseInt(country.values[i].key) < 97
						&& country.values[i].key != "")) {

					var total = 0;
					var oArr = [];
					var catObj = { "key": country.values[i].key };

					for (var j in country.values[i].values) {
						if (parseInt(country.values[i].values[j].key) < 97) {
							total = total + country.values[i].values[j].values.length;
							var t = {
								"key": country.values[i].values[j].key,
								"percent": country.values[i].values[j].values.length,
								"color": color(country.values[i].values[j].key)
							}

							oArr.push(t);
						}
					}

					for (var i in oArr) {
						oArr[i].percent = ((oArr[i].percent / total) * 100).toFixed(2);
					}
					catObj.breakdown = oArr;
					temp.push(catObj);
				}
			}
		}
		return temp;
	}

	// Draw each participants response and place under subcategories
	function drawClusters(data, objArr, countIndex, filter) {
		if (simulation != null) { simulation.stop(); }
		var filKey;  // Data key associated with active filter
		var percents;
		var width = d3.select(".data-wrapper")
		    	.node()
		    	.getBoundingClientRect().width,
		    height = d3.select(".data-wrapper")
		    	.node()
		    	.getBoundingClientRect()
		    	.height + 100;
		var clusters = [
				{ "key": "0" },
				{ "key": "1" },
				{ "key": "2" },
				{ "key": "3" },
				{ "key": "4" },
				{ "key": "5" },
				{ "key": "6" },
				{ "key": "7" },
				{ "key": "8" },
				{ "key": "9" },
				{ "key": "10" }
		    ];

		switch(filter) {
			case "Happy":
				filKey = qHappiness;
				percents = happyCountryNest[countIndex];
				break;
			case "Sex":
				filKey = qGender;
				percents = countrySexHappy[countIndex];
				break;
			case "Age":
				filKey = qAge;
				percents = countryAgeHappy[countIndex];
				break;
			case "Job Status":
				filKey = qEmployment;
				percents = countryEmployHappy[countIndex];
				break;
			case "Marital Status":
				filKey = qRelationship;
				percents = countryRelHappy[countIndex];
				break;
			case "# of Children":
				filKey = qChildren;
				percents = countryChildHappy[countIndex];
				break;
			default:
				filKey = "Something went wrong...";
				percents = "God, what is happening";
		}

		simulation = d3.forceSimulation()
            .force("collide",d3.forceCollide(2).strength(0))
            .force("charge", d3.forceManyBody().strength(-5))
            .force("y", d3.forceY(function(d) {
            		var temp = -999;  // Lazily hide the things that don't apply
            		for (var i = 0; i < objArr.length; i++) {
            			if (d[filKey].includes(objArr[i].key) || filKey == qHappiness) {
            				// Add first data point of color group to array and gravitate to center
            				if (d[qHappiness] < 97 
            					&& clusters[d[qHappiness]][objArr[i].key] == null) {
            					clusters[d[qHappiness]][objArr[i].key] = {
            						"point": d,
            						"y": objArr[i].y,
            						"x": objArr[i].x
            					};
            					temp = objArr[i].y;
            				} else if (d[qHappiness] < 97) {
            					// gravitate other points to first point of color group
            					temp = clusters[d[qHappiness]][objArr[i].key].y;
            				}
            			}
            		}
	            	return temp;
	            })
            	.strength(0.7))
            .force("x", d3.forceX(function(d) {
            		var temp = -999;
            		for (var i = 0; i < objArr.length; i++) {
            			if (d[filKey].includes(objArr[i].key) || filKey == qHappiness) {
            				if (d[qHappiness] < 97 
            					&& clusters[d[qHappiness]][objArr[i].key].point == d) {
            					temp = objArr[i].x;
            				} else if (d[qHappiness] < 97) {
            					temp = clusters[d[qHappiness]][objArr[i].key].x;
            				}
            			}
            		}
	            	return temp;
            	})
            	.strength(0.7))
            .force("cluster", clustering);

		
		var svg = d3.select(".data-wrapper").append("svg").attr("width", width).attr("height", height);
		var circles = svg.selectAll("circle").data(data[countIndex].values);
		var centers = svg.selectAll("circle").data(objArr);

		//console.log(happyCountryNest);


	    // var color = d3.scaleLinear()
	    // .domain([0, 10])
	    // .range(["#0C00FF", "#FF9C00"]);

	    var color = d3.scaleLinear()
	    .domain([0,1,2,3,4,5,6,7,8,9,10])
	    .range(["#000", "#46535a", "#465f2c", 
	    		"#984350", "#91719a", "#f5c750", 
	    		"#a8c9d9", "#c1dea0", "#d796a5", 
	    		"#cdb5d7", "#f3d998"]);

	    /* "#000", "#46535a", "#465f2c", 
	    		"#984350", "#91719a", "#f5c750", 
	    		"#a8c9d9", "#c1dea0", "#d796a5", 
	    		"#cdb5d7", "#f3d998" 
			
			"#f3d998", "#c1dea0", "#cdb5d7", 
	    		"#a8c9d9", "#d796a5", "#8bcf82", 
	    		"#ec5eb2", "#48c1ef", "#4dff33", 
	    		"#ffb31a", "#fff100"

	    		*/

	    var colorArr = [];
	    for (var i = 0; i < 11; i++) {
	    	colorArr.push(color(i));
	    }

		var circle = circles.enter()
			.append("circle")
			.attr("r", 2)
			.attr("fill", function(d, i) {
				var happy = d[qHappiness];
				if (parseInt(happy) < 97 && happy != "") {
					return color(happy);
				} else {
					return "black";
				}
			});

		var center = centers.enter()
			.append("circle")
			.attr("id", function(d) {
				return "cent" + d.key;
			})
			.attr("r", 50)
			.attr("fill", "transparent")
			.attr("cx", function(d) {
				return d.x;
			})
			.attr("cy", function(d) {
				return d.y;
			})
			.on("mouseover", function(d) {
				// d3.select(this).attr("fill", "red");
				var pw = d3.select(".data-wrapper").append("div").attr("class", "percent-wrap");
				var pwBox = pw.node().getBoundingClientRect();
				var x = pwBox.left + (pwBox.width / 2);
				var y = pwBox.top + (pwBox.height / 2);

				yOffset = d3.select(".data-wrapper").node().getBoundingClientRect().top;
				xOffset = d3.select(".data-wrapper").node().getBoundingClientRect().left;

				var t = yOffset - d.y + 50;
				var l = d.x - x - 50;
				pw.style("left", l+"px").style("top", t+"px");
				if (filKey == qHappiness) {
					var cp = calcPercent(percents, true);
					for (var i in cp) {
						pw.append("div")
							.attr("class", "percent")
							.html(
								cp[i].key + ": " +
								cp[i].percent + "%")
							.style("background-color", cp[i].color)
							.style("transform-origin", x + "px  "+ y + "px")
							.style("transform", "rotate(" + i*(360/cp.length) + "deg)");
					}
				} else {
					var cp = calcPercent(percents);
					for (var i in cp) {
						if (d.key == cp[i].key) {
							for (var j in cp[i].breakdown) {
								pw.append("div")
									.attr("class", "percent")
									.html(
										cp[i].breakdown[j].key + ": " + 
										cp[i].breakdown[j].percent + "%")
									.style("background-color", cp[i].breakdown[j].color)
									.style("transform-origin", x + "px  "+ y + "px")
									.style("transform", "rotate(" + j*(360/cp[i].breakdown.length) + "deg)");
							}
						}
					}
				}
			})
			.on("mouseout", function(d) {
				// d3.select(this).attr("fill", "black");
				d3.select(".percent-wrap").remove();
			});


        // cluster the color groups
        function clustering(alpha) {
		    circle.each(function(d) {
		    	if (d[filKey] != "Refused" 
		    		&& d[filKey] != "Dont know" 
		    		&& d[filKey] != "" 
		    		&& d[qHappiness] < 97
		    		&& (isNaN(d[filKey]) || d[filKey] < 97))
		    	{
		    		// magic math stuff
		        	var cluster = clusters[d[qHappiness]][d[filKey]];
		        	if (filKey == qHappiness) { 
		        		cluster = clusters[d[qHappiness]]["Happiness"];
		        	};

				    var x = d.x - cluster.x,
				        y = d.y - cluster.y,
				        l = Math.sqrt(x * x + y * y),
				        r = 4;
				    if (l !== r) {
				    	l = (l - r) / l * alpha;
				        d.x -= x *= l; 
				        d.y -= y *= l;
				        cluster.x += x;
				        cluster.y += y;
				    }
		    	}
		    });
		}

        function ticked(e) {
            circle
                .attr("cx", function(d) { return d.x; })
                .attr("cy", function(d) { return d.y; });
        }
        
        simulation
            .nodes(data[countIndex].values)
            .on("tick", ticked)
            .alphaDecay(0.007);
	}

	d3.csv("Global Attitudes - shortCSV.csv", function(error, data) {
		function nestDataBy(category) {
			return d3.nest()
				.key(function(d, i) {
					return d[category];
				})
				.entries(data);
		}

		function nest2DataBy(c1, c2) {
			return d3.nest()
				.key(function(d) {
					return d[c1];
				})
				.key(function(d) {
					return d[c2];
				})
				.entries(data);
		}

		function nest3DataBy(c1, c2, c3) {
			return d3.nest()
				.key(function(d) {
					return d[c1];
				})
				.key(function(d) {
					return d[c2];
				})
				.key(function(d) {
					return d[c3];
				})
				.entries(data);
		}

		countryNest = nestDataBy("Country");
		happyNest = nestDataBy(qHappiness);
		genderNest = nestDataBy(qGender);
		ageNest = nestDataBy(qAge);
		employmentNest = nestDataBy(qEmployment);
		relationshipNest = nestDataBy(qRelationship);
		childrenNest = nestDataBy(qChildren);
		happyCountryNest = nest2DataBy("Country", qHappiness);
		countrySexHappy = nest3DataBy("Country", qGender, qHappiness);
		countryAgeHappy = nest3DataBy("Country", qAge, qHappiness);
		countryEmployHappy = nest3DataBy("Country", qEmployment, qHappiness);
		countryRelHappy = nest3DataBy("Country", qRelationship, qHappiness);
		countryChildHappy = nest3DataBy("Country", qChildren, qHappiness);

		// Calculate average happiness for each country and push to avgQ2ByCountry
  		for (var i = 0; i < countryNest.length; i++) {
  			var temp = 0;
  			var total = countryNest[i].values.length;
  			for (var j = 0; j < countryNest[i].values.length; j++) {
  				var val = countryNest[i].values[j][qHappiness];
  				if (!isNaN(parseInt(val)) && parseInt(val) != 98 && parseInt(val) != 99) {
  					temp = temp + parseInt(val);
  				} else { total = total - 1; }
  			}
  			var average = temp / total;
  			avgQ2ByCountry.push(average);
  		}

	  	console.log(countryNest);
	  	drawAvg(countryNest);

	  	// for (var i = 0; i < countryNest.length; i++) {
	  	// 	drawPix(countryNest[i]);
	  	// }
	});
</script>